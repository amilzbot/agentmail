/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, type AccountMeta, type AccountSignerMeta, type Address, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type Instruction, type InstructionWithAccounts, type InstructionWithData, type ReadonlyAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount, type WritableSignerAccount } from '@solana/kit';
import { AGENTMAIL_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const DEREGISTER_AGENT_DISCRIMINATOR = 5;

export function getDeregisterAgentDiscriminatorBytes() { return getU8Encoder().encode(DEREGISTER_AGENT_DISCRIMINATOR); }

export type DeregisterAgentInstruction<TProgram extends string = typeof AGENTMAIL_PROGRAM_ADDRESS, TAccountAgentAuthority extends string | AccountMeta<string> = string, TAccountAgentRegistry extends string | AccountMeta<string> = string, TAccountAgentmailProgram extends string | AccountMeta<string> = string, TRemainingAccounts extends readonly AccountMeta<string>[] = []> =
Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array> & InstructionWithAccounts<[TAccountAgentAuthority extends string ? WritableSignerAccount<TAccountAgentAuthority> & AccountSignerMeta<TAccountAgentAuthority> : TAccountAgentAuthority, TAccountAgentRegistry extends string ? WritableAccount<TAccountAgentRegistry> : TAccountAgentRegistry, TAccountAgentmailProgram extends string ? ReadonlyAccount<TAccountAgentmailProgram> : TAccountAgentmailProgram, ...TRemainingAccounts]>;

export type DeregisterAgentInstructionData = { discriminator: number;  };

export type DeregisterAgentInstructionDataArgs = {  };

export function getDeregisterAgentInstructionDataEncoder(): FixedSizeEncoder<DeregisterAgentInstructionDataArgs> {
    return transformEncoder(getStructEncoder([['discriminator', getU8Encoder()]]), (value) => ({ ...value, discriminator: DEREGISTER_AGENT_DISCRIMINATOR }));
}

export function getDeregisterAgentInstructionDataDecoder(): FixedSizeDecoder<DeregisterAgentInstructionData> {
    return getStructDecoder([['discriminator', getU8Decoder()]]);
}

export function getDeregisterAgentInstructionDataCodec(): FixedSizeCodec<DeregisterAgentInstructionDataArgs, DeregisterAgentInstructionData> {
    return combineCodec(getDeregisterAgentInstructionDataEncoder(), getDeregisterAgentInstructionDataDecoder());
}

export type DeregisterAgentInput<TAccountAgentAuthority extends string = string, TAccountAgentRegistry extends string = string, TAccountAgentmailProgram extends string = string> =  {
  agentAuthority: TransactionSigner<TAccountAgentAuthority>;
agentRegistry: Address<TAccountAgentRegistry>;
agentmailProgram: Address<TAccountAgentmailProgram>;
}

export function getDeregisterAgentInstruction<TAccountAgentAuthority extends string, TAccountAgentRegistry extends string, TAccountAgentmailProgram extends string, TProgramAddress extends Address = typeof AGENTMAIL_PROGRAM_ADDRESS>(input: DeregisterAgentInput<TAccountAgentAuthority, TAccountAgentRegistry, TAccountAgentmailProgram>, config?: { programAddress?: TProgramAddress } ): DeregisterAgentInstruction<TProgramAddress, TAccountAgentAuthority, TAccountAgentRegistry, TAccountAgentmailProgram> {
  // Program address.
const programAddress = config?.programAddress ?? AGENTMAIL_PROGRAM_ADDRESS;

 // Original accounts.
const originalAccounts = { agentAuthority: { value: input.agentAuthority ?? null, isWritable: true }, agentRegistry: { value: input.agentRegistry ?? null, isWritable: true }, agentmailProgram: { value: input.agentmailProgram ?? null, isWritable: false } }
const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;




const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
return Object.freeze({ accounts: [getAccountMeta(accounts.agentAuthority), getAccountMeta(accounts.agentRegistry), getAccountMeta(accounts.agentmailProgram)], data: getDeregisterAgentInstructionDataEncoder().encode({}), programAddress } as DeregisterAgentInstruction<TProgramAddress, TAccountAgentAuthority, TAccountAgentRegistry, TAccountAgentmailProgram>);
}

export type ParsedDeregisterAgentInstruction<TProgram extends string = typeof AGENTMAIL_PROGRAM_ADDRESS, TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[]> = { programAddress: Address<TProgram>;
accounts: {
agentAuthority: TAccountMetas[0];
agentRegistry: TAccountMetas[1];
agentmailProgram: TAccountMetas[2];
};
data: DeregisterAgentInstructionData; };

export function parseDeregisterAgentInstruction<TProgram extends string, TAccountMetas extends readonly AccountMeta[]>(instruction: Instruction<TProgram> & InstructionWithAccounts<TAccountMetas> & InstructionWithData<ReadonlyUint8Array>): ParsedDeregisterAgentInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 3) {
  // TODO: Coded error.
  throw new Error('Not enough accounts');
}
let accountIndex = 0;
const getNextAccount = () => {
  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
  accountIndex += 1;
  return accountMeta;
}
  return { programAddress: instruction.programAddress, accounts: { agentAuthority: getNextAccount(), agentRegistry: getNextAccount(), agentmailProgram: getNextAccount() }, data: getDeregisterAgentInstructionDataDecoder().decode(instruction.data) };
}