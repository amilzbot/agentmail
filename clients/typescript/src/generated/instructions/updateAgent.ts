/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, type AccountMeta, type AccountSignerMeta, type Address, type Codec, type Decoder, type Encoder, type Instruction, type InstructionWithAccounts, type InstructionWithData, type ReadonlyAccount, type ReadonlySignerAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount } from '@solana/kit';
import { AGENTMAIL_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import { getStringDecoder, getStringEncoder, type String, type StringArgs } from '../types';

export const UPDATE_AGENT_DISCRIMINATOR = 4;

export function getUpdateAgentDiscriminatorBytes() { return getU8Encoder().encode(UPDATE_AGENT_DISCRIMINATOR); }

export type UpdateAgentInstruction<TProgram extends string = typeof AGENTMAIL_PROGRAM_ADDRESS, TAccountAgentAuthority extends string | AccountMeta<string> = string, TAccountAgentRegistry extends string | AccountMeta<string> = string, TAccountAgentmailProgram extends string | AccountMeta<string> = string, TRemainingAccounts extends readonly AccountMeta<string>[] = []> =
Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array> & InstructionWithAccounts<[TAccountAgentAuthority extends string ? ReadonlySignerAccount<TAccountAgentAuthority> & AccountSignerMeta<TAccountAgentAuthority> : TAccountAgentAuthority, TAccountAgentRegistry extends string ? WritableAccount<TAccountAgentRegistry> : TAccountAgentRegistry, TAccountAgentmailProgram extends string ? ReadonlyAccount<TAccountAgentmailProgram> : TAccountAgentmailProgram, ...TRemainingAccounts]>;

export type UpdateAgentInstructionData = { discriminator: number; name: String; inboxUrl: String;  };

export type UpdateAgentInstructionDataArgs = { name: StringArgs; inboxUrl: StringArgs;  };

export function getUpdateAgentInstructionDataEncoder(): Encoder<UpdateAgentInstructionDataArgs> {
    return transformEncoder(getStructEncoder([['discriminator', getU8Encoder()], ['name', getStringEncoder()], ['inboxUrl', getStringEncoder()]]), (value) => ({ ...value, discriminator: UPDATE_AGENT_DISCRIMINATOR }));
}

export function getUpdateAgentInstructionDataDecoder(): Decoder<UpdateAgentInstructionData> {
    return getStructDecoder([['discriminator', getU8Decoder()], ['name', getStringDecoder()], ['inboxUrl', getStringDecoder()]]);
}

export function getUpdateAgentInstructionDataCodec(): Codec<UpdateAgentInstructionDataArgs, UpdateAgentInstructionData> {
    return combineCodec(getUpdateAgentInstructionDataEncoder(), getUpdateAgentInstructionDataDecoder());
}

export type UpdateAgentInput<TAccountAgentAuthority extends string = string, TAccountAgentRegistry extends string = string, TAccountAgentmailProgram extends string = string> =  {
  agentAuthority: TransactionSigner<TAccountAgentAuthority>;
agentRegistry: Address<TAccountAgentRegistry>;
agentmailProgram: Address<TAccountAgentmailProgram>;
name: UpdateAgentInstructionDataArgs["name"];
inboxUrl: UpdateAgentInstructionDataArgs["inboxUrl"];
}

export function getUpdateAgentInstruction<TAccountAgentAuthority extends string, TAccountAgentRegistry extends string, TAccountAgentmailProgram extends string, TProgramAddress extends Address = typeof AGENTMAIL_PROGRAM_ADDRESS>(input: UpdateAgentInput<TAccountAgentAuthority, TAccountAgentRegistry, TAccountAgentmailProgram>, config?: { programAddress?: TProgramAddress } ): UpdateAgentInstruction<TProgramAddress, TAccountAgentAuthority, TAccountAgentRegistry, TAccountAgentmailProgram> {
  // Program address.
const programAddress = config?.programAddress ?? AGENTMAIL_PROGRAM_ADDRESS;

 // Original accounts.
const originalAccounts = { agentAuthority: { value: input.agentAuthority ?? null, isWritable: false }, agentRegistry: { value: input.agentRegistry ?? null, isWritable: true }, agentmailProgram: { value: input.agentmailProgram ?? null, isWritable: false } }
const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;


// Original args.
const args = { ...input,  };




const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
return Object.freeze({ accounts: [getAccountMeta(accounts.agentAuthority), getAccountMeta(accounts.agentRegistry), getAccountMeta(accounts.agentmailProgram)], data: getUpdateAgentInstructionDataEncoder().encode(args as UpdateAgentInstructionDataArgs), programAddress } as UpdateAgentInstruction<TProgramAddress, TAccountAgentAuthority, TAccountAgentRegistry, TAccountAgentmailProgram>);
}

export type ParsedUpdateAgentInstruction<TProgram extends string = typeof AGENTMAIL_PROGRAM_ADDRESS, TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[]> = { programAddress: Address<TProgram>;
accounts: {
agentAuthority: TAccountMetas[0];
agentRegistry: TAccountMetas[1];
agentmailProgram: TAccountMetas[2];
};
data: UpdateAgentInstructionData; };

export function parseUpdateAgentInstruction<TProgram extends string, TAccountMetas extends readonly AccountMeta[]>(instruction: Instruction<TProgram> & InstructionWithAccounts<TAccountMetas> & InstructionWithData<ReadonlyUint8Array>): ParsedUpdateAgentInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 3) {
  // TODO: Coded error.
  throw new Error('Not enough accounts');
}
let accountIndex = 0;
const getNextAccount = () => {
  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
  accountIndex += 1;
  return accountMeta;
}
  return { programAddress: instruction.programAddress, accounts: { agentAuthority: getNextAccount(), agentRegistry: getNextAccount(), agentmailProgram: getNextAccount() }, data: getUpdateAgentInstructionDataDecoder().decode(instruction.data) };
}